import numpy as np

class Pattern:
    """
    Represents a single piece of art generated by a NEAT-optimized neural network.
    """

    def __init__(self, neural_network, metadata=None):
        """
        Initializes a pattern with a NEAT neural network.

        Args:
            neural_network (NeuralNetwork): NEAT-based neural network wrapper
            metadata (dict): Additional evolutionary context
        """
        self.neural_network = neural_network
        self.metadata = metadata if metadata else {}
        self.fitness = 0
        self.canvas = None
        self.generate_pattern()

    def generate_pattern(self):
        """
        Generates artwork using NEAT neural network.
        Handles various output sizes and normalizes values.
        """
        try:
            # Generate input matching NEAT configuration
            input_size = self.neural_network.config.genome_config.num_inputs
            input_data = np.random.rand(input_size)
            
            # Get network output
            output = self.neural_network.forward(input_data)
            
            # Normalize output to [0, 1]
            output_normalized = (output - np.min(output)) / (np.max(output) - np.min(output) + 1e-7)
            
            # Create best possible square canvas
            total_pixels = len(output_normalized)
            side_length = int(np.sqrt(total_pixels))
            
            # Handle non-perfect squares by truncating
            if side_length ** 2 != total_pixels:
                output_normalized = output_normalized[:side_length ** 2]
                print(f"Adjusted output size from {total_pixels} to {side_length ** 2} pixels")
                
            self.canvas = output_normalized.reshape(side_length, side_length)
            
        except Exception as e:
            print(f"Pattern generation error: {e}")
            self.canvas = np.random.rand(10, 10)  # Fallback pattern

    def evaluate_fitness(self, fitness_evaluator):
        """
        Evaluates pattern fitness using provided evaluator.
        """
        self.fitness = fitness_evaluator.evaluate_objective(self)

    def __repr__(self):
        """
        Provides pattern summary with NEAT-specific information.
        """
        network_info = self.neural_network.__repr__()
        return (f"Pattern(Fitness: {self.fitness:.2f}, "
                f"Canvas: {self.canvas.shape if self.canvas is not None else 'None'}, "
                f"Network: {network_info})")